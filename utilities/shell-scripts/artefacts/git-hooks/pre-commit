#!/bin/bash

# check whether it is a config or code repository
IS_CONFIG={{ IS_CONFIG }}
# IS_CONFIG=N
# check whether it is a file-based or repo-based PDI setup
IS_REPO_BASED={{ IS_REPO_BASED }}
#IS_REPO_BASED=N
TEST_FAILED=" - Test - [\e[31m FAILED\e[39m ]"
TEST_PASSED=" - Test - [\e[32m PASSED\e[39m ]"
GIT_ROOT_DIR=`git rev-parse --show-toplevel`
declare -i STAT=0

# color scales: http://misc.flogisoft.com/bash/tip_colors_and_formatting

# utiltiy functions
function print_header {
  echo -e "\e[34m\e[47mRunning $@ Test\e[0m"
}

function print_failed {
  echo -e $@ ${TEST_FAILED}
}

function print_passed {
  echo -e ${TEST_PASSED}
}


# Check for non ASCII filenames
function check_for_non_ascii_filenames {
 
  TEST_NAME="ASCII Characters Filename Check"
  print_header ${TEST_NAME}
 
  declare -i NUMBER_OF_NON_ASCII_FILE_NAMES=0
 
  # printable range starts at space character and ends with tilde
  # Note that the brackets around the tr range are required for portability
  # to Solari's /usr/bin/tr. The square bracket bytes happen to fall in
  # the designated space
  NON_ASCII_FILE_NAMES=`git diff --cached --name-only | LC_ALL=C tr -d '[ -~]\0'`
  NUMBER_OF_NON_ASCII_FILE_NAMES=`echo ${NON_ASCII_FILE_NAMES} | wc -w`
 
  
  echo "Number of non ASCII file names: ${NUMBER_OF_NON_ASCII_FILE_NAMES}"
 
  # error message if unacceptable files present
  if [ ${NUMBER_OF_NON_ASCII_FILE_NAMES} -gt 0 ]; then
    print_failed ${TEST_NAME}
    echo -e "\e[93mPlease only use ASCII characters for filenames!"
    echo -e "Following filenames contain non ASCII characters:"
    echo -e "${NON_ASCII_FILE_NAMES}\n"
    STAT=1
  else
    print_passed ${TEST_NAME}
  fi
  return ${STAT}
 
}


function check_for_paths_with_whitespaces  {

  TEST_NAME="Check for whitespaces in file paths"
  print_header ${TEST_NAME}

  declare -i NUMBER_OF_PATHS_WITH_WHITESPACES=0

  PATHS_WITH_WHITESPACES=`find . -path pdi/.meta -prune -o -print | grep -E ".*\s.*"`
  NUMBER_OF_PATHS_WITH_WHITESPACES=`echo ${PATHS_WITH_WHITESPACES} | wc -w`  

  echo "Number of paths with whitespaces: ${NUMBER_OF_PATHS_WITH_WHITESPACES}"

  # error message if unacceptable files present
  if [ ${NUMBER_OF_PATHS_WITH_WHITESPACES} -gt 0 ]; then
    print_failed ${TEST_NAME}
    echo -e "\e[93mPlease remove whitespaces!\e[39m"
    echo -e "Following paths contain whitespaces:"
    echo -e "${PATHS_WITH_WHITESPACES}\n"
    STAT=1
  else
    print_passed ${TEST_NAME}
  fi
  return ${STAT}
}
 
# Check new files meet naming convention
function check_new_pdi_files_meet_naming_convention {
 
  TEST_NAME="Naming Convention"
  print_header ${TEST_NAME}
 
  declare -i NUMBER_OF_UNACCEPTABLE_PDI_FILES=0
 
  # Get a list of new files to be pushed
  # Check which transformations don't match with the following patterns:
  # jb_filename.kjb, tr_filename.ktr
  UNACCPETABLE_NEW_PDI_FILES=$( git diff --cached --name-only | grep -Ev "(.*/)?tr\_[a-z0-9\_]+\.ktr$|(.*/)?jb\_[a-z0-9\_]+\.kjb$" | grep -E "ktr$|kjb$"|| (echo ""))
   
  # if the list is not empty ...
  if [ ! -z "${UNACCPETABLE_NEW_PDI_FILES}" ]; then
    NUMBER_OF_UNACCEPTABLE_PDI_FILES=$(echo ${UNACCPETABLE_NEW_PDI_FILES} | wc -w)
  fi
 
  echo "Number of unacceptable new PDI file names: ${NUMBER_OF_UNACCEPTABLE_PDI_FILES}"
 
  # error message if unacceptable files present
  if [ ${NUMBER_OF_UNACCEPTABLE_PDI_FILES} -gt 0 ]; then
    print_failed ${TEST_NAME}
    echo -e "\e[93mPlease only use alphanumberic filenames!"
    echo -e "Jobs/Transformations must follow the pattern:"
    echo -e " - tr_filename.ktr"
    echo -e " - jb_filename.kjb\e[39m"
    echo -e "\e[93mThe following filename(s) do not meet filename conventions:\e[39m"
    echo -e "${UNACCPETABLE_NEW_PDI_FILES}\n"
    STAT=1
  else
    print_passed ${TEST_NAME}
  fi
  return ${STAT}
}
 
# Check for jobs and transformations whose repository path does not match their filesystem path
# applies to file-repo setup only
function check_repo_path {
 
  TEST_NAME="Check Repo Paths"
  print_header ${TEST_NAME}
  cd ${GIT_ROOT_DIR}/pdi
 
  declare -i COUNTER=0

  # change internal file separator so that spaces in file and folder names
  # dont cause havoc
  SAVEIFS=${IFS}
  IFS=$(echo -en "\n\b")

  for MY_FILE in `find . ! -type d -name '*ktr' -or -name '*kjb'`
  do
    FOLDER=$(dirname ${MY_FILE})
    # get rid of the `./pdi/` starting bit
    FOLDER=`echo ${FOLDER} | cut -c 2-`
    # `grep -m 1` replaced with `grep ... | head -n1` since some older systems do not support the first option
    REPO_FOLDER=$(grep '<directory>' $MY_FILE | head -n1 | \
      sed -e 's| *<directory>||g' \
          -e 's|&#x2f;|/|g' \
          -e 's|</directory>.*||g')
    if [[ ! "${FOLDER}" = "${REPO_FOLDER}" ]]; then
      echo "${MY_FILE} -> FILESYSTEM: ${FOLDER} -> REPO: ${REPO_FOLDER}"
      STAT=1
      COUNTER=COUNTER+1
    fi
  done

  # restore IFS
  IFS=${SAVEIFS}
 
  if [ ${COUNTER} -gt 0 ]; then
    print_failed ${TEST_NAME}
  else
    print_passed ${TEST_NAME}
  fi
 
  return ${STAT}
}
 
 
# Check for PDI files with hardcoded IP addresses
# grep -Er "[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}" .
function check_hardcoded_ip {
 
  TEST_NAME="Check Hardcoded IP"
  print_header ${TEST_NAME}
  cd ${GIT_ROOT_DIR}/pdi
 
  FILES_WITH_HARDCODED_IP=""
  declare -i NUMBER_OF_FILES_WITH_HARDCODED_IP=0
 
  FILES_WITH_HARDCODED_IP=$(grep -Erl "[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}" .  || (echo ""))
  # if the list is not empty ...
  if [ ! -z "${FILES_WITH_HARDCODED_IP}" ]; then
    NUMBER_OF_FILES_WITH_HARDCODED_IP=$(echo ${FILES_WITH_HARDCODED_IP} | wc -w )
  fi
 
  echo "Number of files PDI files with hardcoded IP addresses: ${NUMBER_OF_FILES_WITH_HARDCODED_IP}"
 
  # error message if unacceptable files present
  if [ ${NUMBER_OF_FILES_WITH_HARDCODED_IP} -gt 0 ]; then
    print_failed ${TEST_NAME}
    echo -e "\e[93mThe following filename(s) do have hard code IP addresses:\e[39m"
    echo -e "${FILES_WITH_HARDCODED_IP}\n"
    STAT=1
  else
    print_passed ${TEST_NAME}
  fi
  return ${STAT}
}
 
# Check for PDI files with hardcoded domain name
function check_hard_coded_domain_name {
 
  TEST_NAME="Check Domain Name"
  print_header ${TEST_NAME}
  cd ${GIT_ROOT_DIR}/pdi
 
  FILES_WITH_HARDCODED_DOMAIN_NAME=""
  declare -i NUMBER_OF_FILES_WITH_HARDCODED_DOMAIN_NAME=0
  # older versions of PDI seems to escape colon and slashes in xml, newer versions not
  # we also make sure that you can define something like this: http://${VAR_NAME}
  FILES_WITH_HARDCODED_DOMAIN_NAME=$(grep -Erl "(https&#x3a;&#x2f;&#x2f;[a-zA-Z]+)|(http&#x3a;&#x2f;&#x2f;[a-zA-Z]+)|(https\:\/\/[a-zA-Z]+)|(http\:\/\/[a-zA-Z]+)|(www\.[a-zA-Z]+)" .  || (echo ""))
  # if the list is not empty ...
  if [ ! -z "${FILES_WITH_HARDCODED_DOMAIN_NAME}" ]; then
    NUMBER_OF_FILES_WITH_HARDCODED_DOMAIN_NAME=$(echo ${FILES_WITH_HARDCODED_DOMAIN_NAME} | wc -w )
  fi
 
  echo "Number of PDI files with hardcoded domain names: ${NUMBER_OF_FILES_WITH_HARDCODED_DOMAIN_NAME}"
 
  # error message if unacceptable files present
  if [ ${NUMBER_OF_FILES_WITH_HARDCODED_DOMAIN_NAME} -gt 0 ]; then
    print_failed ${TEST_NAME}
    echo -e "\e[93mThe following filename(s) do have hard code Domain Names:\e[39m"
    echo -e "${FILES_WITH_HARDCODED_DOMAIN_NAME}\n"
    STAT=1
  else
    print_passed ${TEST_NAME}
  fi
  return ${STAT}
}
 
 
# Check new files matches accepted file types
function check_supported_file_type {
 
  TEST_NAME="Accepted File Type"
  print_header ${TEST_NAME}
  declare -i NUMBER_OF_NOT_SUPPORTED_NEW_FILES=0
 
  # Get a list of new files to be pushed
  # Check if they match a list of accepted file extensions
  # Keep non matching ones
  if [ ${IS_CONFIG} = "Y" ]; then
    NOT_SUPPORTED_NEW_FILES=$(git diff --cached --name-only |
      # non-accepted file types
      grep --invert-match -E "md$|properties$|sh$|json$|xml$|txt$|csv$"||
      (echo ""))
   else
     NOT_SUPPORTED_NEW_FILES=$(git diff --cached --name-only |
      # non-accepted file types
      grep --invert-match -E "cda$|cdfde$|css$|csv$|html$|jpeg$|js$|json$|kdb$|kjb$|ktr$|md$|png$|prpt$|prpti$|sh$|svg$|txt$|wcdf$|xanalyzer$|xmi$|xml"||
      (echo ""))
    fi
  # if the list is not empty ...
  if [ ! -z "${NOT_SUPPORTED_NEW_FILES}" ]; then
    NUMBER_OF_NOT_SUPPORTED_NEW_FILES=$(echo $NOT_SUPPORTED_NEW_FILES | wc -w)
  fi
 
  echo "Number of files with not supported file types: ${NUMBER_OF_NOT_SUPPORTED_NEW_FILES}"
 
  # error message if unacceptable files present
  if [ ${NUMBER_OF_NOT_SUPPORTED_NEW_FILES} -gt 0 ]; then
    print_failed ${TEST_NAME}
    echo -e "\e[93mThe following filename(s) do not match the list of accepted file extensions:\e[39m"
    echo -e "${NOT_SUPPORTED_NEW_FILES}\n"
    STAT=1
  else
    print_passed ${TEST_NAME}
  fi
  return ${STAT}
}
 
function check_supported_branch_name {
 
  TEST_NAME="supported Branch Name"
  print_header ${TEST_NAME}
 
  declare -i VALID_BRANCH_NAME_COUNT=0
 
  BRANCH_NAME=`git branch | while read STAR BRANCH; do echo $BRANCH; done`
 
  VALID_BRANCH_NAME_COUNT=$(echo BRANCH_NAME | grep -E "^master$|^feature\_.+|^release\_.+|^hotfix\_.+" | wc -w)
 
 
  # error message if unacceptable files present
  if [ ${VALID_BRANCH_NAME_COUNT} = 0 ]; then
    print_failed ${TEST_NAME}
    echo -e "\e[93mThe following branch name does not match the list of accepted ones:\e[39m"
    echo -e ${BRANCH_NAME}
    echo -e "Accepted Branch Names: master, feature_*, release_*, hotfix_*"
    STAT=1
  else
    print_passed ${TEST_NAME}
  fi
  return ${STAT}
}
 
# Check defined database connections do match a predefined list
function check_defined_database_connections_are_part_of_the_project {
 
  TEST_NAME="Check Defined Databases Are Part of the Project"
  print_header ${TEST_NAME}
  cd ${GIT_ROOT_DIR}/pdi
 
  # get connection references that do not match a predefined list
  # grep -Erl "<connection>" -A+1 . | grep "<name>" | cut -d'>' -f2 | cut -d'<' -f1 | grep -cvE "hive_generic|impala_generic|mysql_process_control"
  # grep -Er "<connection>.*?</connection>" .
 
  FILES_WITH_DB_CONNECTION_DEFINITION=$(grep -Erl "*.<connection>*." || (echo ""))
 
  declare -i FILES_WITH_DB_CONNECTION_DEFINITION_COUNTER=0
  FILES_WITH_INVALID_DB_CONNECTION_DEFINITION=()

  # change internal file separator so that spaces in file and folder names
  # dont cause havoc
  SAVEIFS=${IFS}
  IFS=$(echo -en "\n\b")

  for FILE_WITH_DB_CONNECTION_REFERENCE in ${FILES_WITH_DB_CONNECTION_DEFINITION}
  do
    LOCAL_COUNTER=$(grep -E "*.<connection>*." -A+1 ${FILE_WITH_DB_CONNECTION_REFERENCE}  | grep "*.<name>*." | cut -d'>' -f2 | cut -d'<' -f1 | sort -u | grep -cvE "hive_generic|impala_generic|mysql_process_control")
    if [ ${LOCAL_COUNTER} -gt 0 ]; then
      FILES_WITH_INVALID_DB_CONNECTION_DEFINITION+=(${FILE_WITH_DB_CONNECTION_REFERENCE})
      FILES_WITH_DB_CONNECTION_DEFINITION_COUNTER+=1
    fi   
  done

  # restore IFS
  IFS=${SAVEIFS}
 
 
  echo "Number of files with project unrelated database definitions: ${FILES_WITH_DB_CONNECTION_DEFINITION_COUNTER}"
  # echo "Number of unacceptable files: ${#FILES_WITH_INVALID_DB_CONNECTION_DEFINITION[*]}"
  # error message if unacceptable files present
  if [ ${FILES_WITH_DB_CONNECTION_DEFINITION_COUNTER} -gt 0 ]; then
    print_failed ${TEST_NAME}
    echo -e "\e[93mThe following filename(s) do have invalid DB connection definitions:\e[39m"
 
 
    for ITEM in ${FILES_WITH_INVALID_DB_CONNECTION_DEFINITION[*]}
    do
      echo -e "${ITEM}"
    done
    STAT=1
  else
    print_passed ${TEST_NAME}
  fi
  return ${STAT}
}
 
# Check connection references do match a predefined list
function check_referenced_database_are_part_of_the_project {
 
  TEST_NAME="Check Referenced Databases Are Part of the Project"
  print_header ${TEST_NAME}
  cd ${GIT_ROOT_DIR}/pdi
 
  # get connection references that do not match a predefined list
  # grep -Er ".*<connection>.*?</connection>.*" .  | cut -d'>' -f2 | cut -d'<' -f1 | sort -u | grep -vE "hive_generic|impala_generic|mysql_process_control"
  # grep -Er ".*<connection>.*?</connection>.*" .
 
  FILES_WITH_DB_CONNECTION_REFERENCE=$(grep -Erl ".*<connection>.*?</connection>.*" --include="*.kjb" --include="*.ktr" --include="*.kdb" .  || (echo ""))
 
  declare -i FILES_WITH_DB_CONNECTION_REFERENCE_COUNTER=0
  FILES_WITH_INVALID_DB_CONNECTION_REFERENCE=()

  # change internal file separator so that spaces in file and folder names
  # dont cause havoc
  SAVEIFS=${IFS}
  IFS=$(echo -en "\n\b")
 
  for FILE_WITH_DB_CONNECTION_REFERENCE in ${FILES_WITH_DB_CONNECTION_REFERENCE}
  do
    # allowed database names specified at the end here - should be externalised in the long term
    LOCAL_COUNTER=$(grep -E ".*<connection>.*?</connection>.*" ${FILE_WITH_DB_CONNECTION_REFERENCE} | cut -d'>' -f2 | cut -d'<' -f1 | sort -u | grep -v "" | grep -cvE "hive_generic|impala_generic|mysql_process_control")
    if [ ${LOCAL_COUNTER} -gt 0 ]; then
      FILES_WITH_INVALID_DB_CONNECTION_REFERENCE+=(${FILE_WITH_DB_CONNECTION_REFERENCE})
      FILES_WITH_DB_CONNECTION_REFERENCE_COUNTER+=1
 
      echo "${FILE_WITH_DB_CONNECTION_REFERENCE} has a non-project specific connection: "
      grep -E ".*<connection>.*?</connection>.*" ${FILE_WITH_DB_CONNECTION_REFERENCE} | cut -d'>' -f2 | cut -d'<' -f1 | sort -u | grep -v "" | grep -vE "hive_generic|impala_generic|mysql_process_control"
 
    fi
  done

  # restore IFS
  IFS=${SAVEIFS}
 
 
  echo "Number of files with non-project specific database connection references: ${FILES_WITH_DB_CONNECTION_REFERENCE_COUNTER}"
  # echo "Number of unacceptable files: ${#FILES_WITH_INVALID_DB_CONNECTION_REFERENCE[*]}"
  # error message if unacceptable files present
  if [ ${FILES_WITH_DB_CONNECTION_REFERENCE_COUNTER} -gt 0 ]; then
    print_failed ${TEST_NAME}
    echo -e "\e[93mThe following filename(s) do have invalid DB references:\e[39m"
 
 
    for ITEM in ${FILES_WITH_INVALID_DB_CONNECTION_REFERENCE[*]}
    do
      echo -e "${ITEM}"
    done
    STAT=1
  else
    print_passed ${TEST_NAME}
  fi
  return ${STAT}
}
 
 
if [ ${IS_CONFIG} = "Y" ]; then
  check_supported_file_type
  check_for_non_ascii_filenames
else
  check_for_paths_with_whitespaces
  check_supported_file_type
  check_for_non_ascii_filenames
  check_new_pdi_files_meet_naming_convention
  check_hardcoded_ip
  check_hard_coded_domain_name
  check_defined_database_connections_are_part_of_the_project
  check_referenced_database_are_part_of_the_project
  if [ ${IS_REPO_BASED} = "Y" ]; then
    check_repo_path
  fi
fi
 
if [ ${STAT} -gt 0 ]; then
  echo ""
  echo -e "[\e[31m Too many errors. Not committing anything. Resolve issues. \e[39m ]"
  echo ""
  exit 1
fi
 
# Check for IPs
 
 
# Check for domain names within server tag
 
# supported extensions:
 
# cda
# cdfde
# css
# csv
# html
# jpeg
# js
# json
# kdb
# kjb
# ktr
# md
# png
# prpt
# prpti
# sh
# svg
# txt
# wcdf
# xanalyzer
# xmi
# xml
 
# csv
# json
# properties
# sh
# txt
# xml
 